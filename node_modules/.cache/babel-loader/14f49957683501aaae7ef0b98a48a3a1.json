{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n\n  return indexes;\n}\n\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\'; // Allow decimal numbers percent in @keyframes\n\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n\n\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;","map":{"version":3,"names":["exports","__esModule","_root","_interopRequireDefault","require","_selector","_className","_comment","_id","_tag","_string","_pseudo","_attribute","_interopRequireWildcard","_universal","_combinator","_nesting","_sortAscending","_tokenize","tokens","types","_util","_WHITESPACE_TOKENS","_Object$assign","_getRequireWildcardCache","WeakMap","cache","obj","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","_createClass","Constructor","protoProps","staticProps","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","assign","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","indexesOf","array","item","indexes","push","uniqs","list","Array","concat","apply","arguments","filter","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","source","errorGenerator","append","current","loop","_proto","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","_unescaped","_oldRawValue","oldValue","quoteMark","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","requiredSpace","_this2","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_this$convertWhitespa","spaceOrDescendantSelectorNodes","_this$convertWhitespa2","_space","_rawSpace","_this$convertWhitespa3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","every","string","firstCallback","_this5","lastIndexOf","hasClass","escapedDot","isKeyframesPercent","test","hasId","interpolations","hashIndex","indices","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","isArray","pop","join","an","required","END_POS","searchPosition","module","default"],"sources":["/Users/vinnyzefran/Desktop/fitnessFrontEnd/node_modules/postcss-selector-parser/dist/parser.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n\n  return indexes;\n}\n\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      // Allow escaped dot within class name\n      var escapedDot = word[i - 1] === '\\\\'; // Allow decimal numbers percent in @keyframes\n\n      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n      return !escapedDot && !isKeyframesPercent;\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}